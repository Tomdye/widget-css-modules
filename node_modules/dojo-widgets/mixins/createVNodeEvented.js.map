{"version":3,"file":"createVNodeEvented.js","sourceRoot":"","sources":["createVNodeEvented.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventTargettedObject, EventObject, Handle } from 'dojo-interfaces/core';\nimport { on } from 'dojo-core/aspect';\nimport { assign } from 'dojo-core/lang';\nimport { ComposeFactory } from 'dojo-compose/compose';\nimport createEvented, { resolveListener } from 'dojo-compose/bases/createEvented';\nimport {\n\tEvented,\n\tEventedOptions,\n\tEventedListenerOrArray,\n\tEventedListenersMap\n} from 'dojo-interfaces/bases';\nimport Set from 'dojo-shim/Set';\nimport { VNodeProperties } from 'dojo-interfaces/vdom';\nimport { NodeAttributeFunction } from './../interfaces';\n\nexport type VNodeListenerReturn = boolean | undefined | null;\n\nexport interface VNodeListeners {\n\t[on: string]: undefined | ((ev?: EventTargettedObject<any>) => VNodeListenerReturn);\n\tontouchcancel?(ev?: TouchEvent): VNodeListenerReturn;\n\tontouchend?(ev?: TouchEvent): VNodeListenerReturn;\n\tontouchmove?(ev?: TouchEvent): VNodeListenerReturn;\n\tontouchstart?(ev?: TouchEvent): VNodeListenerReturn;\n\tonblur?(ev?: FocusEvent): VNodeListenerReturn;\n\tonchange?(ev?: Event): VNodeListenerReturn;\n\tonclick?(ev?: MouseEvent): VNodeListenerReturn;\n\tondblclick?(ev?: MouseEvent): VNodeListenerReturn;\n\tonfocus?(ev?: FocusEvent): VNodeListenerReturn;\n\toninput?(ev?: Event): VNodeListenerReturn;\n\tonkeydown?(ev?: KeyboardEvent): VNodeListenerReturn;\n\tonkeypress?(ev?: KeyboardEvent): VNodeListenerReturn;\n\tonkeyup?(ev?: KeyboardEvent): VNodeListenerReturn;\n\tonload?(ev?: Event): VNodeListenerReturn;\n\tonmousedown?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseenter?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseleave?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmousemove?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseout?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseover?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseup?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmousewheel?(ev?: MouseWheelEvent): VNodeListenerReturn;\n\tonscroll?(ev?: UIEvent): VNodeListenerReturn;\n\tonsubmit?(ev?: Event): VNodeListenerReturn;\n}\n\nconst vnodeEvents = new Set([\n\t'touchcancel',\n\t'touchend',\n\t'touchmove',\n\t'touchstart',\n\t'blur',\n\t'change',\n\t'click',\n\t'dblclick',\n\t'focus',\n\t'input',\n\t'keydown',\n\t'keypress',\n\t'keyup',\n\t'load',\n\t'mousedown',\n\t'mouseenter',\n\t'mouseleave',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'mousewheel',\n\t'scroll',\n\t'submit'\n]);\n\nexport interface VNodeEventedMixin {\n\t/**\n\t * A map of listeners that are exposed for use by the virutal DOM\n\t */\n\tlisteners: VNodeListeners;\n\n\t/**\n\t * An array of functions the provide the VNode attributes when rendering\n\t */\n\tnodeAttributes: NodeAttributeFunction<this>[];\n}\n\nexport interface VNodeEventedOverrides {\n\ton(type: 'touchcancel', listener: EventedListenerOrArray<EventTarget, TouchEvent>): Handle;\n\ton(type: 'touchend', listener: EventedListenerOrArray<EventTarget, TouchEvent>): Handle;\n\ton(type: 'touchmove', listener: EventedListenerOrArray<EventTarget, TouchEvent>): Handle;\n\ton(type: 'blur', listener: EventedListenerOrArray<EventTarget, FocusEvent>): Handle;\n\ton(type: 'change', listener: EventedListenerOrArray<EventTarget, Event>): Handle;\n\ton(type: 'click', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'dblclick', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'focus', listener: EventedListenerOrArray<EventTarget, FocusEvent>): Handle;\n\ton(type: 'input', listener: EventedListenerOrArray<EventTarget, Event>): Handle;\n\ton(type: 'keydown', listener: EventedListenerOrArray<EventTarget, KeyboardEvent>): Handle;\n\ton(type: 'keypress', listener: EventedListenerOrArray<EventTarget, KeyboardEvent>): Handle;\n\ton(type: 'keyup', listener: EventedListenerOrArray<EventTarget, KeyboardEvent>): Handle;\n\ton(type: 'load', listener: EventedListenerOrArray<EventTarget, Event>): Handle;\n\ton(type: 'mousedown', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mouseenter', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mouseleave', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mousemove', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mouseout', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mouseover', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mouseup', listener: EventedListenerOrArray<EventTarget, MouseEvent>): Handle;\n\ton(type: 'mousewheel', listener: EventedListenerOrArray<EventTarget, MouseWheelEvent>): Handle;\n\ton(type: 'scroll', listener: EventedListenerOrArray<EventTarget, UIEvent>): Handle;\n\ton(type: 'submit', listener: EventedListenerOrArray<EventTarget, Event>): Handle;\n}\n\nexport type VNodeEvented = Evented & VNodeEventedMixin & VNodeEventedOverrides;\n\nexport type VNodeEventedOptions = EventedOptions;\n\nexport interface VNodeEventedFactory extends ComposeFactory<VNodeEvented, VNodeEventedOptions> { }\n\n/**\n * Internal function to convert an array of handles to a single array\n *\n * TODO: This is used in a couple places, maybe should migrate to a better place\n *\n * @params handles An array of handles\n */\nfunction handlesArraytoHandle(handles: Handle[]): Handle {\n\treturn {\n\t\tdestroy() {\n\t\t\thandles.forEach((handle) => handle.destroy());\n\t\t}\n\t};\n}\n\nconst UNINITIALIZED_LISTENERS = Object.freeze({});\n\nconst createVNodeEvented: VNodeEventedFactory = createEvented\n\t.mixin({\n\t\tmixin: {\n\t\t\tlisteners: UNINITIALIZED_LISTENERS,\n\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: any): VNodeProperties {\n\t\t\t\t\treturn assign({}, this.listeners);\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\taspectAdvice: {\n\t\t\taround: {\n\t\t\t\ton(origFn): (...args: any[]) => Handle {\n\t\t\t\t\treturn function (this: VNodeEvented, ...args: any[]): Handle {\n\t\t\t\t\t\tif (args.length === 2) { /* overload: on(type, listener) */\n\t\t\t\t\t\t\t/* During initialization, sometimes the initialize functions occur out of order,\n\t\t\t\t\t\t\t* and Evented's initialize function could be called before this mixins, therefore\n\t\t\t\t\t\t\t* leaving this.listeners with an uninitiliazed value, therefore it is better to\n\t\t\t\t\t\t\t* determine if the value is unitialized here, ensuring that this.listeners is\n\t\t\t\t\t\t\t* always valid.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tif (this.listeners === UNINITIALIZED_LISTENERS) {\n\t\t\t\t\t\t\t\tthis.listeners = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet type: string;\n\t\t\t\t\t\t\tlet listeners: EventedListenerOrArray<VNodeEvented, EventTargettedObject<any>>;\n\t\t\t\t\t\t\t[ type, listeners ] = args;\n\t\t\t\t\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\t\t\t\t\tconst handles = listeners.map((listener) => vnodeEvents.has(type) ?\n\t\t\t\t\t\t\t\t\ton(this.listeners, 'on' + type, resolveListener(listener)) :\n\t\t\t\t\t\t\t\t\torigFn.call(this, type, listener));\n\t\t\t\t\t\t\t\treturn handlesArraytoHandle(handles);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn vnodeEvents.has(type) ?\n\t\t\t\t\t\t\t\t\ton(this.listeners, 'on' + type, resolveListener(listeners)) :\n\t\t\t\t\t\t\t\t\torigFn.call(this, type, listeners);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (args.length === 1) { /* overload: on(listeners) */\n\t\t\t\t\t\t\tconst listenerMapArg: EventedListenersMap<any> = args[0];\n\t\t\t\t\t\t\treturn handlesArraytoHandle(Object.keys(listenerMapArg).map((type) => this.on(type, listenerMapArg[type])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { /* unexpected signature */\n\t\t\t\t\t\t\tthrow new TypeError('Invalid arguments');\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\temit(origFn): <T extends EventObject>(event: T) => void {\n\t\t\t\t\treturn function <T extends EventObject>(this: VNodeEvented, event: T): void {\n\t\t\t\t\t\tif (vnodeEvents.has(event.type)) {\n\t\t\t\t\t\t\tif (this.listeners === null) {\n\t\t\t\t\t\t\t\tthis.listeners = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst method = this.listeners['on' + event.type];\n\t\t\t\t\t\t\tif (method) {\n\t\t\t\t\t\t\t\tmethod.call(this, event);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\torigFn.call(this, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\nexport default createVNodeEvented;\n"]}
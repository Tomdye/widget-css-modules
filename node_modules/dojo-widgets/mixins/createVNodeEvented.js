(function (dependencies, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(dependencies, factory);
    }
})(["require", "exports", "dojo-core/aspect", "dojo-core/lang", "dojo-compose/bases/createEvented", "dojo-shim/Set"], function (require, exports) {
    "use strict";
    var aspect_1 = require("dojo-core/aspect");
    var lang_1 = require("dojo-core/lang");
    var createEvented_1 = require("dojo-compose/bases/createEvented");
    var Set_1 = require("dojo-shim/Set");
    var vnodeEvents = new Set_1.default([
        'touchcancel',
        'touchend',
        'touchmove',
        'touchstart',
        'blur',
        'change',
        'click',
        'dblclick',
        'focus',
        'input',
        'keydown',
        'keypress',
        'keyup',
        'load',
        'mousedown',
        'mouseenter',
        'mouseleave',
        'mousemove',
        'mouseout',
        'mouseover',
        'mouseup',
        'mousewheel',
        'scroll',
        'submit'
    ]);
    /**
     * Internal function to convert an array of handles to a single array
     *
     * TODO: This is used in a couple places, maybe should migrate to a better place
     *
     * @params handles An array of handles
     */
    function handlesArraytoHandle(handles) {
        return {
            destroy: function () {
                handles.forEach(function (handle) { return handle.destroy(); });
            }
        };
    }
    var UNINITIALIZED_LISTENERS = Object.freeze({});
    var createVNodeEvented = createEvented_1.default
        .mixin({
        mixin: {
            listeners: UNINITIALIZED_LISTENERS,
            nodeAttributes: [
                function () {
                    return lang_1.assign({}, this.listeners);
                }
            ]
        },
        aspectAdvice: {
            around: {
                on: function (origFn) {
                    return function () {
                        var _this = this;
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        if (args.length === 2) {
                            /* During initialization, sometimes the initialize functions occur out of order,
                            * and Evented's initialize function could be called before this mixins, therefore
                            * leaving this.listeners with an uninitiliazed value, therefore it is better to
                            * determine if the value is unitialized here, ensuring that this.listeners is
                            * always valid.
                            */
                            if (this.listeners === UNINITIALIZED_LISTENERS) {
                                this.listeners = {};
                            }
                            var type_1;
                            var listeners = void 0;
                            type_1 = args[0], listeners = args[1];
                            if (Array.isArray(listeners)) {
                                var handles = listeners.map(function (listener) { return vnodeEvents.has(type_1) ?
                                    aspect_1.on(_this.listeners, 'on' + type_1, createEvented_1.resolveListener(listener)) :
                                    origFn.call(_this, type_1, listener); });
                                return handlesArraytoHandle(handles);
                            }
                            else {
                                return vnodeEvents.has(type_1) ?
                                    aspect_1.on(this.listeners, 'on' + type_1, createEvented_1.resolveListener(listeners)) :
                                    origFn.call(this, type_1, listeners);
                            }
                        }
                        else if (args.length === 1) {
                            var listenerMapArg_1 = args[0];
                            return handlesArraytoHandle(Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); }));
                        }
                        else {
                            throw new TypeError('Invalid arguments');
                        }
                    };
                },
                emit: function (origFn) {
                    return function (event) {
                        if (vnodeEvents.has(event.type)) {
                            if (this.listeners === null) {
                                this.listeners = {};
                            }
                            var method = this.listeners['on' + event.type];
                            if (method) {
                                method.call(this, event);
                            }
                        }
                        else {
                            origFn.call(this, event);
                        }
                    };
                }
            }
        }
    });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = createVNodeEvented;
});
//# sourceMappingURL=createVNodeEvented.js.map